/*******************************
 * Ethernet packet capture program
 * Liang Guan (guanl@umich.edu)
 * 18 May 2016
 * Modified by: 
 * Yuxiang Guo (gyuxiang@umich.edu)
 * Jan 30 2020
 * How to run
 * g++ -std=c++11 EthernetCap.cpp -lpcap -o mac_daq
 *****************************/


#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <iostream>
#include <string.h>
#include <getopt.h>

#include <signal.h>  /*for signal() and raise()*/
#include <pcap.h>  
#include <errno.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <cstdlib>
#include <math.h>


using namespace std;




void gotPacket(u_char *useless, 
					const struct pcap_pkthdr* pkthdr, const u_char* packet_data);

class BinRecord
{
public:
	BinRecord();
	int chnlNum;
	int fineCount[4];	
};

BinRecord::BinRecord(){
	chnlNum = 99;
	memset(fineCount, 0, sizeof(fineCount));
}

class BinDebug : public BinRecord
{
public:
	BinDebug();
	int isRisingEdge;
	int fineQ[16];	
};

BinDebug::BinDebug(){
	isRisingEdge = 0;
	memset(fineQ, 0, sizeof(fineQ));	
}

class PcapDev
{
public:
	PcapDev();
	~PcapDev();
	pcap_t *pcapHandle_;
	char *dev_;  //device name
	int packetReceiver();
	
};

class EthernetCap
{
public:
	EthernetCap(string runId, int dataCount);
	~EthernetCap();
	void setMinusFlagTrue();
	void setBinsizeFlagTrue();
	void setDebugFlagTrue();
	void setBinSaveTrue();
	void setBinName(string bName);
	void setTdcMode(string mode);
	void setCsvSaveTrue();
	void setCheckPacketFlagTrue();
	void setIsRisingEdgeTrue();
	void openFiles();
	void init(int chnlCount);
	void binsize_record(const struct pcap_pkthdr* pkthdr, const u_char* packet_data);
	void binsize_result(BinRecord *p);	
	void binsize_debug(const struct pcap_pkthdr* pkthdr, const u_char* packet_data);
	void binsize_debug_result(BinDebug *p);
	void two_hit_resolve(const struct pcap_pkthdr* pkthdr, const u_char* packet_data);
	void twohit_std_cal();
	void checkPacket(const struct pcap_pkthdr* pkthdr, const u_char* packet_data);
	void close();
	int dataIndex();
	int hitCount();
	int minusFlag();
	int binsizeFlag();
	int debugFlag();
	int checkPacketFlag();

private:
	bool minusFlag_, binsizeFlag_, debugFlag_, binSave_, csvSave_, checkPacketFlag_;
	string runId_, bName_;
	FILE *fp_binary_, *fp_csv_;
	int dataCount_, chnlCount_;
	BinRecord *pBinRecord_;
	BinDebug *pBinDebug_;	
	int hitCount_;
	int chnl_flag_;
	int chnl1_,chnl2_,last_chl_, wait_for_second_hit_;
	int leading_edge1_, leading_edge2_;
	int *dataValue_, dataIndex_;
	int packetNum_, packetNumLast_;
	int isRisingEdge_;
	int pairMode_, edgeMode_;
};
EthernetCap *p_ecap;


PcapDev::PcapDev(){
	pcap_if_t *alldevs;
  pcap_if_t *d;
  char err_buf[PCAP_ERRBUF_SIZE];	
  char packet_filter[]="ether src ff:ff:ff:c7:05:01"; //filter expression
  bpf_u_int32 netmask=0xffffff; 
  struct bpf_program fcode; // compile filter program  
  int i = 0;
  if (pcap_findalldevs(&alldevs, err_buf) == -1)
  {
      cerr <<"Error in pcap_findalldevs_ex:"<< err_buf << endl;
      exit(1);
  }
  // for(d= alldevs; d != NULL; d= d->next)
  // {
  //     cout << ++i << ":"<< d->name <<"    ";
  //     if (d->description)
  //         cout << d->description << endl;
  //     else
  //         cout<< "(No description available)" << endl;
  // }
  int device_number;
  // cout << "plese select your etherner device: ";
  // cin >> device_number;
  //please set according to your host's ethernert port
  device_number=1;

  d= alldevs;
  for(i=0; i < device_number -1; i++){
      d=d->next;        
  }
  //cout << ++i << ":"<< d->name <<"    ";
  if (d->description)
      cout << d->description << endl;
  else
      cout<< "(No description available)" << endl;

  /* open the ethernet device*/
  //dev = pcap_lookupdev(err_buf);
  //if (dev==NULL){
  //    cout<<"Could not find device "<<dev<<" : "<<err_buf<<endl;
  //    return -1;
  //}else{
//printf("Found Device %s\n",dev);
  //}
  dev_ = d->name;
  pcapHandle_ = pcap_open_live(dev_,65536,1,10000, err_buf);  //device name, snap length, promiscuous mode, to_ms, error_buffer
  if (pcapHandle_==NULL){
    cout<<"Could not open device "<<dev_<<" : "<<err_buf<<endl;
		exit(1);
  }   

  /* compile the filter */
  if (pcap_compile(pcapHandle_, &fcode, packet_filter, 1, netmask) < 0){
    cout<<"Unable to compile the packet filter. Check the syntax!"<<endl;
    pcap_close(pcapHandle_);
    exit(1);
  }

  /* apply filter*/ 
  if (pcap_setfilter(pcapHandle_, &fcode) < 0){
    cout<<"Filter address error. Can not apply filter!"<<endl;
    pcap_close(pcapHandle_);
    exit(1);
  }
  pcap_freecode(&fcode); 
  // pcap_freecode() is used to free up allocated memory pointed to by a
	// bpf_program struct generated by pcap_compile(3PCAP) when that BPF
	// program is no longer needed, for example after it has been made the
	// filter program for a pcap structure by a call to
	// pcap_setfilter(3PCAP).
	pcap_freealldevs(alldevs);
}

PcapDev::~PcapDev(){
	pcap_close(pcapHandle_);
}


int PcapDev::packetReceiver(){

    int ret=0;
    int fd=0;   //define a file descriptor 
    fd_set rfds; //file descriptor sets for "select" function (it's a bit arrray)
    struct timeval tv;  // strcuture represents elapsed time (declared in sys/time.h)
    const int TIMEOUT=60;  //timeout in seconds

    fd=pcap_fileno(pcapHandle_); //pcap_fileno returns the descriptor for the packet capture device
    FD_ZERO(&rfds);   //re-clears(empty) file descriptor set 
    FD_SET(fd,&rfds); //rebuild file descriptor set
    
    tv.tv_sec=TIMEOUT;
    tv.tv_usec=0;
 
    ret=select(fd+1, &rfds, NULL, NULL, &tv); 
    //select(): blocks the calling process until there is activity on file descriptor set or until the timeout period has expired
 
    if(-1==ret) cout<<"Select failed"<<endl;
    else if(ret){
        pcap_dispatch(pcapHandle_,1, gotPacket,NULL);
    }else{
        //#ifdef DEBUG
                cout<<"Select timeout on fd:"<<fd<<" Return code: "<<ret<<endl;
        //#endif
    }
    return ret;
}





EthernetCap::EthernetCap(string runId, int dataCount){
	minusFlag_ = 0;
	binsizeFlag_ = 0;
	debugFlag_ = 0;
	binSave_ = 0;
	csvSave_ = 0;
	runId_ = runId;
	dataCount_ = dataCount;
	chnl_flag_ = 0;
	hitCount_ = 0;
	chnl1_ = 99;
	chnl2_ = 99;
	last_chl_ = 99;
	wait_for_second_hit_ = 0;
	isRisingEdge_ = 0;
	pairMode_ = 1;
	edgeMode_ = 0;
}



void EthernetCap::init(int chnlCount){
	
	if(minusFlag_)
		chnlCount_ = 2;
	else
		chnlCount_ = chnlCount;

	if(binsizeFlag_){
		pBinRecord_ = new BinRecord[chnlCount_];
	}

  if(debugFlag_){
	  pBinDebug_ = new BinDebug[chnlCount_]; 
	}

	if(minusFlag_){
		dataValue_ = new int[dataCount_];
	}
	openFiles();

}

EthernetCap::~EthernetCap(){
	if(binsizeFlag_){
		delete[] pBinRecord_;
	}
  if(debugFlag_){
	  delete[] pBinDebug_; 
	}
	if(minusFlag_){
		delete[] dataValue_;
	}
	if(binSave_)
		fclose(fp_binary_);
	if(csvSave_)
		fclose(fp_csv_);
};


int EthernetCap::dataIndex(){
	return dataIndex_;
}
int EthernetCap::hitCount(){
	return hitCount_;
}
int EthernetCap::minusFlag(){
	return minusFlag_;
}
int EthernetCap::binsizeFlag(){
	return binsizeFlag_;
}
int EthernetCap::debugFlag(){
	return debugFlag_;
}
int EthernetCap::checkPacketFlag(){
	return checkPacketFlag_;
}



void EthernetCap::setMinusFlagTrue(){
	if(debugFlag_){
		printf("Debug mode on, can't set minus flag!\n");
		exit(1);
	}
	else
		minusFlag_ = 1;
}

void EthernetCap::setBinsizeFlagTrue(){
	if(debugFlag_){
		printf("Debug mode on, can't set minus flag!\n");
		exit(1);
	}
	else
		binsizeFlag_ = 1;
}

void EthernetCap::setDebugFlagTrue(){
	if(minusFlag_ || binsizeFlag_){
		printf("Mode conflicted, can't set debug flag!\n");
		exit(1);
	}
	else
		debugFlag_ = 1;
}


void EthernetCap::setBinSaveTrue(){
	binSave_ = 1;
}
void EthernetCap::setBinName(string bName){
	bName_ = bName;
}
void EthernetCap::setTdcMode(string mode){
	pairMode_ = 0;
	edgeMode_ = 0;
	if (mode == "pair")
		pairMode_ = 1;
	else if (mode == "edge"){
		edgeMode_ = 1;
	  
	}
	else if (mode == "debug")
		setDebugFlagTrue();
	else{
		cout<<"Please check mode option"<<endl;
		exit(0);
	}
	cout<<"edgeMode_="<<edgeMode_<<endl;
	cout<<"pairMode_="<<pairMode_<<endl;

}
void EthernetCap::setCsvSaveTrue(){
	csvSave_ = 1;
}
void EthernetCap::setIsRisingEdgeTrue(){
	isRisingEdge_ = 1;
}
void EthernetCap::setCheckPacketFlagTrue(){
	checkPacketFlag_ = 1;
}

void EthernetCap::openFiles(){
	string runName;
	if(binSave_){
		runName="run_"+runId_+"_"+bName_+".dat";
  	fp_binary_=fopen(runName.c_str(),"wb");
  	if(fp_binary_==0){
  		printf("Could not open file %s!\n",runName.c_str());
  		exit(1);
  	}
	}
	if(csvSave_){
		runName="run_"+runId_+".csv";
  	fp_csv_=fopen(runName.c_str(),"a+");
  	fprintf(fp_csv_,"pair=,%d,edge=,%d,chnl_count=,%d\n",pairMode_,edgeMode_,
  		chnlCount_);
  	if(fp_csv_==0){
  		printf("Could not open file %s!\n",runName.c_str());
  		exit(1);
  	}
	}
}


	// bool minusFlag_, binsizeFlag_, debugFlag_, binSave_, csvSave_;
	// BinRecord *pBinRecord_;
	// BinDebug *pBinDebug_;	

void gotPacket(u_char *useless, 
					const struct pcap_pkthdr* pkthdr, const u_char* packet_data)
{    
	// if(binary_save_flag)binary_save(useless,pkthdr,packet_data);
	//csv_save(useless,pkthdr,packet_data);

	if(p_ecap->minusFlag())
		p_ecap->two_hit_resolve(pkthdr,packet_data);
	if(p_ecap->binsizeFlag())
		p_ecap->binsize_record(pkthdr,packet_data);
	if(p_ecap->debugFlag())
		p_ecap->binsize_debug(pkthdr,packet_data);
	if(p_ecap->checkPacketFlag())
		p_ecap->checkPacket(pkthdr,packet_data);
}


void EthernetCap::checkPacket(const struct pcap_pkthdr* pkthdr, const u_char* packet_data){		
	int length;

	length=pkthdr->len;  //last 4 bytes stand for packet ID
	// int* p_int;
	// p_int = (int*)(packet_data+length-4);
	// packetNum_ = *p_int;

	// printf("packet = 0x%02x%02x%02x%02x\n",*(packet_data+length-4),
	// 	*(packet_data+length-3),*(packet_data+length-2),*(packet_data+length-1));

	packetNum_=(int)(*(packet_data+length-2))*256+(int)(*(packet_data+length-1));
	// printf("Receiving packet %d\n",packetNum_);
	if(packetNum_!=(packetNumLast_+1)%65536){ 
		
		if(packetNumLast_!=0) {

			// printf("warning:packet_lost! Packet = %d, Last = %d\n", packetNum_, packetNumLast_);
			printf("%d\n", (packetNum_-packetNumLast_+65536)%65536);
		}
	}	    
	packetNumLast_=packetNum_;
}


void EthernetCap::binsize_record(const struct pcap_pkthdr* pkthdr, 
	const u_char* packet_data){
	int length;
	int chnlNum;
	length=((pkthdr->len-18))/5;  //bytes  preload=14 postload=4
	for(int i=0;i<length;i++){
		if(pairMode_)
			chnlNum=*(packet_data+i*5+15)/8;
		else if(edgeMode_)
			chnlNum=*(packet_data+i*5+16)/8;
		if(chnlNum>30)continue;
		if(chnlNum>23){
			printf("Decoding error! Chnl id = %d! \n", chnlNum);
			exit(1);
		}
		for(int j=0;j<chnlCount_;j++){ //search for the right chl
			if(pBinRecord_[j].chnlNum ==99){
				pBinRecord_[j].chnlNum = chnlNum;
			}
			else if(chnlNum != pBinRecord_[j].chnlNum){
				if(j==chnlCount_-1)printf("warning:Got a hit from chnl %d! \n", chnlNum);
				continue;
			}
			if(pairMode_)
				pBinRecord_[j].fineCount[(int)(*(packet_data+i*5+17))%4]++; //fine time count ++
			else if(edgeMode_)
				pBinRecord_[j].fineCount[(int)(*(packet_data+i*5+18))%4]++; //fine time count ++
			if(minusFlag_==0)
				hitCount_++;
			break;
		}
	}
}

void EthernetCap::binsize_result(BinRecord *p){
	int count;
	count = p->fineCount[0]+p->fineCount[1]+
					p->fineCount[2]+p->fineCount[3];
	double s=(double)count;
	double bin0, bin1, bin2, bin3;
	bin0 = p->fineCount[0]/s*3125;
	bin1 = p->fineCount[1]/s*3125;
	bin2 = p->fineCount[2]/s*3125;
	bin3 = p->fineCount[3]/s*3125;
	printf("\n////////////////////////\n");
	printf("chl %d count=%d\n",p->chnlNum,count);
	printf("count	for 0,1,2,3=	%d,	%d,	%d,	%d\n",p->fineCount[0],
				p->fineCount[1],p->fineCount[2],p->fineCount[3]);
	printf("binsize	for 0,1,2,3=	%.4f,	%.4f,	%.4f,	%.4f\n", bin0,bin1,bin2,bin3);
	// fprintf(stderr,"%02d,%d,%s,",p->chnlNum,count,isRisingEdge_?"r":"f");	
	// fprintf(stderr,"%.4f,%.4f,%.4f,%.4f,",bin0,bin1,bin2,bin3);
	if(csvSave_){
		// fprintf(fp_csv_,"chl_id,total,0,1,2,3\n");
		fprintf(fp_csv_,"%02d,%d,%s,",p->chnlNum,count,isRisingEdge_?"r":"f");	
		fprintf(fp_csv_,"%.4f,%.4f,%.4f,%.4f\n",bin0,bin1,bin2,bin3);
	}	
}


void EthernetCap::binsize_debug(const struct pcap_pkthdr* pkthdr, 
	const u_char* packet_data){
	int length;
	int first_word_received = 0;
	unsigned int word_tmp = 0;
	unsigned int word1 = 0;
	int chnlNum;

	//debug word:
	//2'b00 + 5'b chnl_ID + 17'b time, followed by:
	//2'b11 + 1'b edge_mode + 2'b hit_counter + 15'b drop_coarse + 4'b fineQ
	length=((pkthdr->len-18))/5;  //TDC data words, 1 TDC word = 5 bytes.  preload=14 postload=4
	for(int i=0;i<length;i++){
		word_tmp = (*(packet_data+i*5+16)<<16)+(*(packet_data+i*5+17)<<8)+
		(unsigned int)*(packet_data+i*5+18);
		// word_tmp = (unsigned int)*(packet_data+i*5+16)*65536+(unsigned int)*(packet_data+i*5+17)*256+(unsigned int)*(packet_data+i*5+18);
		if((word_tmp>>17)<24){   //found first debug word
			word1 = word_tmp;
			first_word_received = 1;
		}
		else if((word_tmp!=0xffffff) && first_word_received && (word_tmp>>22==3)){ //found second debug word
			chnlNum = word1>>17;
			for(int j=0;j<chnlCount_;j++){ //search for the right chl
				if(pBinDebug_[j].chnlNum ==99){
					pBinDebug_[j].chnlNum = chnlNum;
					pBinDebug_[j].isRisingEdge = (word_tmp>>21) &0x1;
				}
				if(chnlNum == pBinDebug_[j].chnlNum){
					pBinDebug_[j].fineCount[word1 & 0x3]++;
					pBinDebug_[j].fineQ[word_tmp & 0xf]++;
					first_word_received = 0;
					hitCount_++;
					break;
				}
				else if(j==chnlCount_-1){
					printf("warning:Got a hit from chnl %d! \n", chnlNum);
				}
			}
		}
	}
}

void EthernetCap::binsize_debug_result(BinDebug *p){
	int count;
	count = p->fineCount[0]+p->fineCount[1]+p->fineCount[2]+p->fineCount[3];
	double s=(double)count;
	printf("////////////////////////\n");
	printf("chl %d count=%d ",p->chnlNum,count);
	if(p->isRisingEdge)printf("rising_edge\n");
	else printf("falling_edge\n");
	printf("count	for 0,1,2,3=	%d,	%d,	%d,	%d\n",p->fineCount[0],p->fineCount[1],
		p->fineCount[2],p->fineCount[3]);
		printf("binsize	for 0,1,2,3=	%07.4f,	%07.4f,	%07.4f,	%07.4f\n", p->fineCount[0]/s*3125,
		p->fineCount[1]/s*3125,p->fineCount[2]/s*3125,p->fineCount[3]/s*3125);
	printf("fineQ 	=	left		left		main\n");
	printf("bin 0	=	%07.4f,	%07.4f,	%07.4f\n",p->fineQ[0xd]/s*3125,
		p->fineQ[0x8]/s*3125,p->fineQ[0x9]/s*3125);
	printf("bin 1	=	%07.4f,	%07.4f,	%07.4f\n",p->fineQ[0xb]/s*3125,
		p->fineQ[0x1]/s*3125,p->fineQ[0x3]/s*3125);
	printf("bin 2	=	%07.4f,	%07.4f,	%07.4f\n",p->fineQ[0x2]/s*3125,
		p->fineQ[0x7]/s*3125,p->fineQ[0x6]/s*3125);
	printf("bin 3	=	%07.4f,	%07.4f,	%07.4f\n",p->fineQ[0x4]/s*3125,
		p->fineQ[0xe]/s*3125,p->fineQ[0xc]/s*3125);
	printf("0 5 a f	=	%07.4f,	%07.4f,	%07.4f,	%07.4f\n",p->fineQ[0x0]/s*3125,
		p->fineQ[0x5]/s*3125,p->fineQ[0x4]/s*3125,p->fineQ[0xf]/s*3125);

	if(csvSave_){
		fprintf(fp_csv_,"chl_id,total,0,1,2,3,");
		if(p->isRisingEdge)fprintf(fp_csv_, "rising_edge\n");
		else fprintf(fp_csv_, "falling_edge\n");

		fprintf(fp_csv_,"%d,%d,",p->chnlNum,count);	
		fprintf(fp_csv_,"%.4f,%.4f,%.4f,%.4f\n",p->fineCount[0]/s*3125,
			p->fineCount[1]/s*3125,p->fineCount[2]/s*3125,p->fineCount[3]/s*3125);
		fprintf(fp_csv_,"fineQ,left,left,main\n");
		fprintf(fp_csv_,"bin0,%.4f,%.4f,%.4f\n",p->fineQ[0xd]/s*3125,
			p->fineQ[0x8]/s*3125,p->fineQ[0x9]/s*3125);
		fprintf(fp_csv_,"bin1,%.4f,%.4f,%.4f\n",p->fineQ[0xb]/s*3125,
			p->fineQ[0x1]/s*3125,p->fineQ[0x3]/s*3125);
		fprintf(fp_csv_,"bin2,%.4f,%.4f,%.4f\n",p->fineQ[0x2]/s*3125,
			p->fineQ[0x7]/s*3125,p->fineQ[0x6]/s*3125);
		fprintf(fp_csv_,"bin3,%.4f,%.4f,%.4f\n",p->fineQ[0x4]/s*3125,
			p->fineQ[0xe]/s*3125,p->fineQ[0xc]/s*3125);
		fprintf(fp_csv_,"bin_05af,%.4f,%.4f,%.4f,%.4f\n",p->fineQ[0x0]/s*3125,
			p->fineQ[0x5]/s*3125,p->fineQ[0x4]/s*3125,p->fineQ[0xf]/s*3125);
	}	
}


void EthernetCap::two_hit_resolve(const struct pcap_pkthdr* pkthdr, const u_char* packet_data){
	int length;
	int chl_num;
	//int local_packet_count;
	//int packet_lost;
	int i=0;
	//int reverse_flag;
	length=((pkthdr->len-18))/5;  //bytes  preload=14 postload=4
	//local_packet_count=(int)(*(packet_data+length-4))*1677716+(int)(*(packet_data+length-3))*65536+(int)(*(packet_data+length-2))*256+(int)(*(packet_data+length-1));
	//packet_lost=(local_packet_count==packetNumLast_+1)?0:1;
	chl_num=*(packet_data+i*5+15)/8;  //first TDC data chl_id

	
	
	for(int i=0;i<length;i++){
		if(dataIndex_>dataCount_)break;
		chl_num=*(packet_data+i*5+15)/8;
		if(chl_num>30)continue;
		if(chnl_flag_ == 2);
		else if (chnl_flag_ == 0 && chnl1_ == 99){
			chnl1_ = chl_num;
			chnl_flag_ = 1;
		}		
		else if (chnl_flag_ == 1 && chnl2_ == 99 && chl_num != chnl1_){
			chnl2_ = chl_num;
			chnl_flag_ = 2;
		}     
		
		if(binSave_){
			fwrite(packet_data+i*5+15,1,4,fp_binary_);
		}

		if(chl_num==chnl1_){
			leading_edge1_=(int)(*(packet_data+i*5+15))%2*65536+(int)(*(packet_data+i*5+16))*256+(int)*(packet_data+i*5+17);
			//printf("chnl1_=%d,leading_edge1_=%d\n",chl_num,leading_edge1_);		 
			if(wait_for_second_hit_==0){  //chnl1_ is the first arrived hit
				wait_for_second_hit_=1;
			}
			else if(last_chl_==chnl2_){    //chnl1_ is the second arrived hit and last hit was chnl2_
				*(dataValue_+dataIndex_)=(chnl1_<chnl2_)?(leading_edge2_-leading_edge1_):(leading_edge1_-leading_edge2_);
				if((*(dataValue_+dataIndex_))>65536) {*(dataValue_+dataIndex_)=-65536*2+*(dataValue_+dataIndex_);}
				else if((*(dataValue_+dataIndex_))<-65536) {*(dataValue_+dataIndex_)=65536*2+*(dataValue_+dataIndex_);}
				//if((*(dataValue_+dataIndex_))>10) printf("chl%d = %d, chl%d = %d\n", chnl1_,leading_edge1_,chnl2_,leading_edge2_);
				dataIndex_++;
				wait_for_second_hit_=0;						
			}
			else
				printf("Warning: consecutive chnl_%d!\n", chl_num);
      last_chl_=chnl1_;
		}
		else if(chl_num==chnl2_){
			leading_edge2_=(int)(*(packet_data+i*5+15))%2*65536+(int)(*(packet_data+i*5+16))*256+(int)*(packet_data+i*5+17);	
			//printf("chnl2_=%d,leading_edge2_=%d\n",chl_num,leading_edge2_);		 
			if(wait_for_second_hit_==0){  //chnl2_ is the first arrived hit
				wait_for_second_hit_=1;
			}
			else if(last_chl_==chnl1_){    //chnl2_ is the second arrived hit and last hit was chnl1_
				*(dataValue_+dataIndex_)=(chnl1_<chnl2_)?(leading_edge2_-leading_edge1_):(leading_edge1_-leading_edge2_);
				if((*(dataValue_+dataIndex_))>65536) {*(dataValue_+dataIndex_)=-65536*2+*(dataValue_+dataIndex_);}
				else if((*(dataValue_+dataIndex_))<-65536) {*(dataValue_+dataIndex_)=65536*2+*(dataValue_+dataIndex_);}
				//if((*(dataValue_+dataIndex_))>10) printf("chl%d = %d, chl%d = %d\n", chnl1_,leading_edge1_,chnl2_,leading_edge2_);
				dataIndex_++;
				wait_for_second_hit_=0;			
			}
			else
				printf("Warning: consecutive chnl_%d!\n", chl_num);
      last_chl_=chnl2_;
		}
		else{
			printf("chnl1 = %d, chnl2=%d, chnl_flag_=%d\n", chnl1_,chnl2_,chnl_flag_);
			printf("Warning: got hit from chnl_%d!(minus flag)\n", chl_num);
		}
	}
	//cout<<"chnl1_=:"<<chnl1_<<"chnl2_=:"<<chnl2_<<"dataIndex_=:"<<dataIndex_<<endl;
}

void EthernetCap::twohit_std_cal(){
	long sum=0;
	double mean=0;
	double rms=0;
	int minus2_number = 0;
	int minus1_number = 0;
	int zero_number = 0;
	int plus1_number = 0;
	int plus2_number = 0;
	int other_number = 0;
	for(int i=0;i<dataIndex_;i++){
		sum+=*(dataValue_+i);
		if (*(dataValue_+i)==-2)
		{
			minus2_number = minus2_number + 1;
		}else if(*(dataValue_+i)==-1){
			minus1_number = minus1_number + 1;
		}else if(*(dataValue_+i)==0){
			zero_number = zero_number + 1;
		}else if(*(dataValue_+i)==1){
			plus1_number = plus1_number + 1;
		}else if(*(dataValue_+i)==2){
			plus2_number = plus2_number + 1;
		}else{
			other_number = other_number +1;
		}
	}
	mean=((double)sum)/dataIndex_;
	for(int i=0;i<dataIndex_;i++){
		rms+=((*(dataValue_+i))-mean)*((*(dataValue_+i))-mean);
	}
	rms=sqrt(rms/(dataIndex_-1));
	printf("chnl1=%d, chnl2=%d, ", chnl1_,chnl2_);
	printf("dataIndex_=%d,mean = %lf, rms = %lf\n",dataIndex_,mean,rms);
	printf("-2 = %d,	-1 = %d,	0 = %d,	+1 = %d,	+2 = %d,\
		other_number = %d\n",minus2_number,minus1_number,
		zero_number,plus1_number,plus2_number,other_number);
	// fprintf(stderr,"%d,%d,%s,%d,%lf,%lf,",chnl1_,chnl2_,isRisingEdge_?"r":"f",
	// 	dataIndex_,mean,rms);
	string tmp;
	tmp = "run_"+runId_+"_"+bName_+".dat";
	if(binSave_)
		fprintf(fp_csv_,"%d,%d,%s,%d,%lf,%lf,%s,",chnl1_,chnl2_,isRisingEdge_?"r":"f",
			dataIndex_,mean,rms,tmp.c_str());
	else
		fprintf(fp_csv_,"%d,%d,%s,%d,%lf,%lf,",chnl1_,chnl2_,isRisingEdge_?"r":"f",
			dataIndex_,mean,rms);

	int maxerror = 0;
	for(int i=0;i<dataIndex_;i++){
		if((*(dataValue_+i)-mean > 2) &&
			((*(dataValue_+i)-mean > 5*rms) || (*(dataValue_+i)-mean <-5*rms))){
			if(maxerror<20){
				maxerror++;
				printf("warning:data[%d]=%d dev > 5*sigma!\n",i,*(dataValue_+i));
			}
			else{
				printf("Warning exceeds 20, display no more\n");
				break;
			}
		}
	}
	return;
}

void EthernetCap::close(){
	if(minusFlag_)
		twohit_std_cal();
  if(binsizeFlag_){
    for(int i=0;i<chnlCount_;i++){
    	binsize_result(pBinRecord_+i);
    }
    // cerr<<runId_+"_"<<endl;
    if(csvSave_)
    	fprintf(fp_csv_,"\n");   
	}
	if(debugFlag_){
		for(int i=0;i<chnlCount_;i++){
			binsize_debug_result(pBinDebug_+i);
		}	
	}
}


bool daq_stop=false;
void signalHandler (int signum){
   daq_stop=true;
   cout<<"DAQ stopped!! --"<<signum<<endl;
}

static void show_usage(string name)
{
  cerr<< "Usage: " << name << " <option(s)>"
			<< "Options:\n"
			<< "\t-h,--help\tShow this help message\n"
			<< "\t-n,--name\tSpecify the run name\n"
			<< "\t-d,--data\tSpecify the expected total count per channel\n"
			<< "\t-c,--channel\tSpecify the number of input channels\n"
			<< "\t-r,--rising\tRising edge\n"
			<< "\t-f,--falling\tFalling edge\n"
			<< "\t-p,--packet\tShow packet lost\n"		
			<< "\t-b,--binary\tSave binary file and specify file name\n"	
			<< "\t-m,--mode\tpair, edge, debug\n"
			<< std::endl;
}

int main(int argc, char **argv){
	    /* get run number*/
  cout<<"========================================================== "<<endl;
  int iPacket = 0;   

  //default values for run arguments 
  string runId = "default";
  string tdcMode = "pair";
  int isRisingEdge = 1;
  int data_count = 10000;
  int show_packet_lost = 0;
  int chnlCount = 2;
  int binary_save = 0;
  string binary_name = "default";
  if(argc < 2){
  	show_usage(argv[0]);
		return 0;
	}

	int c;
	while (1) {
		int this_option_optind = optind ? optind : 1;
		int option_index = 0;
		static struct option long_options[] = {
		    {"help",    no_argument, 				0,  'h' },           
		    {"rising",  no_argument, 				0,  'r' },
		    {"falling", no_argument,       	0,  'f' },           
		    {"packet",  no_argument, 				0,  'p' },
		    {"name",  	required_argument,  0,  'n' },
		    {"data",  	required_argument, 	0, 	'd'	},
		    {"channel", required_argument, 	0,  'c' },
		    {"binary",  required_argument, 	0,  'b' },
		    {"mode",  	required_argument, 	0,  'm' }
		};
		c = getopt_long(argc, argv, "hrfpn:d:c:b:",long_options, &option_index);
		if (c == -1) break;
		switch (c) {
			case 'h':
				show_usage(argv[0]);
		  	return 0;
		  case 'r':
		  	isRisingEdge = 1;break;
		  case 'f':
		  	isRisingEdge = 0;break;
		  case 'p':
		  	show_packet_lost = 1;break;
		  case 'n':
		  	runId = optarg;break;
		  case 'd':
		  	data_count = stoi(optarg);break;
		  case 'c':
		  	chnlCount = stoi(optarg);break;
		  case 'b':
		  	binary_name = optarg;
				binary_save = 1;break;
			case 'm':
				tdcMode = optarg;break;
			case '?':
				cerr<<"unknown or missing arguments!"<<endl;
		    show_usage(argv[0]);
		  	return 0;
		  default:break;            
		}
  }

  // exit(EXIT_SUCCESS);
  cout<<"run pid is: "<<getpid()<<endl; 
  cout<<"run number: "<<runId<<" data_count: "<<data_count<<" chnl_count "
  		<<chnlCount<<" edge = "<<isRisingEdge<<" mode = "<<tdcMode<<endl; 
 
  p_ecap = new EthernetCap(runId, data_count);

  //user defined setup for current run
  if(show_packet_lost)
  	p_ecap->setCheckPacketFlagTrue();
  if(isRisingEdge)
  	p_ecap->setIsRisingEdgeTrue();
  if(binary_save){
  	p_ecap->setBinSaveTrue();
  	p_ecap->setBinName(binary_name);
  }
  p_ecap->setTdcMode(tdcMode);


  p_ecap->setBinsizeFlagTrue();  
  p_ecap->setCsvSaveTrue();  
  // p_ecap->setMinusFlagTrue();
  
  p_ecap->init(chnlCount);
  PcapDev *p_Dev = new PcapDev();
  signal(SIGUSR1,signalHandler);

	while(p_Dev->packetReceiver()!=0 && daq_stop==false && p_ecap->dataIndex()<data_count 
		&& p_ecap->hitCount()<data_count*chnlCount);

  p_ecap->close();
  delete p_ecap;
  delete p_Dev;
  cout<<"//////Run finished!//////"<<endl;
  return 0;
}
